(* Module Terms -- abstract syntax of CN terms *)

module CT = Sctypes

type loc = Cerb_location.t

(* CN constants *)
type const =
  | Z of Z.t
  | Bits of (BaseTypes.sign * int) * Z.t
  | Q of Q.t
  | Pointer of
      { alloc_id : Z.t;
        addr : Z.t
      }
  | Alloc_id of Z.t
  | Bool of bool
  | Unit
  | Null
  | CType_const of Sctypes.ctype
  | Default of BaseTypes.t

(* type consts functions (autogenerated) *)
val equal_const : const -> const -> Ppx_deriving_runtime.bool

val compare_const : const -> const -> Ppx_deriving_runtime.int

(* CN unary operators *)
type unop =
  | Not
  | Negate
  | BW_CLZ_NoSMT
  | BW_CTZ_NoSMT
  | BW_FFS_NoSMT
  | BW_FLS_NoSMT
  | BW_Compl

(* type unary functions (autogenerated) *)
val equal_unop : unop -> unop -> Ppx_deriving_runtime.bool

val compare_unop : unop -> unop -> Ppx_deriving_runtime.int

val pp_unop : Ppx_deriving_runtime.Format.formatter -> unop -> Ppx_deriving_runtime.unit

val show_unop : unop -> Ppx_deriving_runtime.string

(* CN binary operators *)
type binop =
  | And
  | Or
  | Implies
  | Add
  | Sub
  | Mul
  | MulNoSMT
  | Div
  | DivNoSMT
  | Exp
  | ExpNoSMT
  | Rem
  | RemNoSMT
  | Mod
  | ModNoSMT
  | XORNoSMT
  | BW_And
  | BWOrNoSMT
  | ShiftLeft
  | ShiftRight
  | LT
  | LE
  | Min
  | Max
  | EQ
  | LTPointer
  | LEPointer
  | SetUnion
  | SetIntersection
  | SetDifference
  | SetMember
  | Subset

(* CN pattern matching acceptable basetypes *)
type 'bt pattern_ =
  | PSym of Sym.t
  | PWild
  | PConstructor of Sym.t * (Id.t * 'bt pattern) list

and 'bt pattern = Pat of 'bt pattern_ * 'bt * loc

(* type 'bt pattern_ functions (autogenerated) *)
(* TODO: BCP: @Apol, I think most of these autogenerated functions are not actually used outside the module, so they can be deleted from the interface.  Possibly some of the other (more "internal") functions can be deleted as well.  Basically, the interface should expose only the functions that are actually used by external clients. *)
val equal_pattern_
  :  ('bt -> 'bt -> Ppx_deriving_runtime.bool) ->
  'bt pattern_ ->
  'bt pattern_ ->
  Ppx_deriving_runtime.bool

val equal_pattern
  :  ('bt -> 'bt -> Ppx_deriving_runtime.bool) ->
  'bt pattern ->
  'bt pattern ->
  Ppx_deriving_runtime.bool

val compare_pattern_
  :  ('bt -> 'bt -> Ppx_deriving_runtime.int) ->
  'bt pattern_ ->
  'bt pattern_ ->
  Ppx_deriving_runtime.int

val compare_pattern
  :  ('bt -> 'bt -> Ppx_deriving_runtime.int) ->
  'bt pattern ->
  'bt pattern ->
  Ppx_deriving_runtime.int

val map_pattern_ : ('a -> 'b) -> 'a pattern_ -> 'b pattern_

val map_pattern : ('a -> 'b) -> 'a pattern -> 'b pattern

(* CN basetype terms *)
type 'bt term_ =
  | Const of const
  | Sym of Sym.t
  | Unop of unop * 'bt term
  | Binop of binop * 'bt term * 'bt term
  | ITE of 'bt term * 'bt term * 'bt term
  | EachI of (int * (Sym.t * BaseTypes.t) * int) * 'bt term
  | Tuple of 'bt term list
  | NthTuple of int * 'bt term
  | Struct of Sym.t * (Id.t * 'bt term) list
  | StructMember of 'bt term * Id.t
  | StructUpdate of ('bt term * Id.t) * 'bt term
  | Record of (Id.t * 'bt term) list
  | RecordMember of 'bt term * Id.t
  | RecordUpdate of ('bt term * Id.t) * 'bt term
  | Constructor of Sym.t * (Id.t * 'bt term) list
  | MemberShift of 'bt term * Sym.t * Id.t
  | ArrayShift of
      { base : 'bt term;
        ct : Sctypes.t;
        index : 'bt term
      }
  | CopyAllocId of
      { addr : 'bt term;
        loc : 'bt term
      }
  | SizeOf of Sctypes.t
  | OffsetOf of Sym.t * Id.t
  | Nil of BaseTypes.t
  | Cons of 'bt term * 'bt term
  | Head of 'bt term
  | Tail of 'bt term
  | NthList of 'bt term * 'bt term * 'bt term
  | ArrayToList of 'bt term * 'bt term * 'bt term
  | Representable of Sctypes.t * 'bt term
  | Good of Sctypes.t * 'bt term
  | Aligned of
      { t : 'bt term;
        align : 'bt term
      }
  | WrapI of Sctypes.IntegerTypes.t * 'bt term
  | MapConst of BaseTypes.t * 'bt term
  | MapSet of 'bt term * 'bt term * 'bt term
  | MapGet of 'bt term * 'bt term
  | MapDef of (Sym.t * BaseTypes.t) * 'bt term
  | Apply of Sym.t * 'bt term list
  | Let of (Sym.t * 'bt term) * 'bt term
  | Match of 'bt term * ('bt pattern * 'bt term) list
  | Cast of BaseTypes.t * 'bt term

and 'bt term = IT of 'bt term_ * 'bt * loc

(* type 'bt term_ functions (autogenerated) *)
val equal_term_
  :  ('bt -> 'bt -> Ppx_deriving_runtime.bool) ->
  'bt term_ ->
  'bt term_ ->
  Ppx_deriving_runtime.bool

val equal_term
  :  ('bt -> 'bt -> Ppx_deriving_runtime.bool) ->
  'bt term ->
  'bt term ->
  Ppx_deriving_runtime.bool

val compare_term_
  :  ('bt -> 'bt -> Ppx_deriving_runtime.int) ->
  'bt term_ ->
  'bt term_ ->
  Ppx_deriving_runtime.int

val compare_term
  :  ('bt -> 'bt -> Ppx_deriving_runtime.int) ->
  'bt term ->
  'bt term ->
  Ppx_deriving_runtime.int

val map_term_ : ('a -> 'b) -> 'a term_ -> 'b term_

val map_term : ('a -> 'b) -> 'a term -> 'b term

(* equal = equal_term          compare = compare_term *)
val equal
  :  ('a -> 'a -> Ppx_deriving_runtime.bool) ->
  'a term ->
  'a term ->
  Ppx_deriving_runtime.bool

val compare
  :  ('a -> 'a -> Ppx_deriving_runtime.int) ->
  'a term ->
  'a term ->
  Ppx_deriving_runtime.int

(* pretty printing function for pattern matching*)
val pp_pattern : 'a pattern -> Pp.document

(* TODO: better understanding, but pretty printing for all the basetype terms *)
val pp
  :  ?atomic:bool ->
  ?f:('bt term -> Pp.document -> Pp.document) ->
  'bt term ->
  Pp.document

(* Makes tree structure for pattern matching *)
val dtree_of_pat : 'a pattern -> Cerb_frontend.Pp_ast.doc_tree

(* Makes tree structure for all the basetype terms *)
val dtree : 'a term -> Cerb_frontend.Pp_ast.doc_tree
